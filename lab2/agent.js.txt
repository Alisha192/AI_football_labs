// agent.js ‚Äî –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø (—Ç–æ—á–Ω—ã–µ —É–¥–∞—Ä—ã –ø–æ –º—è—á—É)
const Msg = require('./msg');
const Localization = require('./localization');
const Navigation = require('./navigation');
const Flags = require('./flags');
const DecisionTree = require('./decisionTree');

class Agent {
    constructor(isGoalie = false) {
        this.position = "l";
        this.run = false;
        this.socket = null;
        this.playerNumber = null;
        this.initialized = false;
        this.isGoalie = isGoalie;

        this.nav = new Navigation();

        this.route = [
            { act: "flag", name: "f r b" },
            { act: "flag", name: "g l" },
            { act: "flag", name: "f c" },
            { act: "dribble", name: "b", goal: "g r" }
        ];

        this.currentRouteIndex = 0;
        this.noTargetCounter = 0;

        this.currentPos = { x: 0, y: 0 };
        this.posHistory = [];
        this.posHistoryMax = 20;
        this.currentOrientation = 0;
        this.visibleObjects = [];

        this.lastSee = null;
        this.lastHear = { referee: null, messages: [] };
        this.lastSense = null;

        this.targetGoal = "g r";

        this.goalScoredTime = 0;
        this.waitingAfterGoal = false;

        this.dribbleState = {
            phase: "approach",
            lastBallDist: 999,
            goalScored: false,
            consecutiveKicks: 0,
            stuckCounter: 0,
            lastBallDir: 0,
            lastGoalDir: 0,
            lastPositions: [],
            stuckThreshold: 10,
            lastKickTime: 0,
            lastTurnTime: 0,
            searchMode: false,
            defensiveMode: "position",
            lastBallDistance: 999,
            sameKickCount: 0,
            lastKickCommand: null,
            missedKicks: 0,          // –°—á–µ—Ç—á–∏–∫ –ø—Ä–æ–º–∞—Ö–æ–≤
            lastKickDistance: 999,    // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –º—è—á–∞ –ø—Ä–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–º —É–¥–∞—Ä–µ
            lastKickResult: false      // –†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É–¥–∞—Ä–∞ (–ø–æ–ø–∞–ª/–Ω–µ –ø–æ–ø–∞–ª)
        };

        this.goalsScored = 0;

        this.decisionTree = new DecisionTree(this);

        this.log("üöÄ", "Agent initialized (IMPROVED KICKING)");
        this.log("üéØ", `Target goal: ${this.targetGoal}`);
    }

    log(level, message, data = null) {
        const timestamp = new Date().toISOString();
        const playerInfo = this.playerNumber ? `[Player ${this.playerNumber}]` : '[Init]';
        let logLine = `${timestamp} ${playerInfo} ${level}: ${message}`;
        if (data) logLine += ` ${JSON.stringify(data)}`;
        console.log(logLine);
    }

    setSocket(socket) {
        this.socket = socket;
        this.log("üîå", "Socket set");
    }

    socketSend(cmd, ...params) {
        const paramStr = params.join(' ');
        const fullCommand = `(${cmd} ${paramStr})`;
        this.log("üì§", `Sending command: ${cmd}`, { params, fullCommand });
        if (this.socket) this.socket.sendMsg(fullCommand);
        else this.log("ERROR", "Socket not set!");
    }

    handleMessage(msg) {
        this.log("üì•", "Raw message received", { msg: msg.substring(0, 100) + (msg.length > 100 ? '...' : '') });
        let data = Msg.parseMsg(msg);
        if (!data) {
            this.log("ERROR", "Failed to parse message", { msg });
            return;
        }
        if (data.cmd == "hear") this.handleHear(data);
        else if (data.cmd == "init") this.handleInit(data);
        else if (data.cmd == "see") this.handleSee(data);
        else if (data.cmd == "sense_body") this.handleSense(data);
        else this.log("DEBUG", `Unhandled command: ${data.cmd}`);
    }

    handleHear(data) {
        const time = data.p[0];
        const sender = data.p[1];
        const message = data.p[2];

        this.log("üëÇ", `Heard: ${sender} -> ${message}`, { time });

        this.lastHear = {
            time,
            sender,
            message,
            referee: sender === "referee" ? message : (this.lastHear ? this.lastHear.referee : null)
        };

        if (sender == "referee") {
            if (message == "play_on") {
                this.log("‚è±Ô∏è", "Game started! Resuming play.");
                this.run = true;
                this.waitingAfterGoal = false;
                this.goalScoredTime = 0;
                this.dribbleState.searchMode = false;
                this.dribbleState.defensiveMode = "position";
                this.dribbleState.missedKicks = 0;
            }

            if (message && message.startsWith("goal_")) {
                this.goalsScored++;
                this.goalScoredTime = time;
                this.waitingAfterGoal = true;

                this.log("üéâ", `‚öΩ‚öΩ‚öΩ GOAL ${this.goalsScored}! ‚öΩ‚öΩ‚öΩ`, { message });

                this.currentRouteIndex = 0;
                this.dribbleState = {
                    phase: "approach",
                    lastBallDist: 999,
                    goalScored: true,
                    consecutiveKicks: 0,
                    stuckCounter: 0,
                    lastBallDir: 0,
                    lastGoalDir: 0,
                    lastPositions: [],
                    stuckThreshold: 10,
                    lastKickTime: 0,
                    lastTurnTime: 0,
                    searchMode: false,
                    defensiveMode: "position",
                    lastBallDistance: 999,
                    sameKickCount: 0,
                    lastKickCommand: null,
                    missedKicks: 0,
                    lastKickDistance: 999,
                    lastKickResult: false
                };
            }

            if (message == "kick_off_r" || message == "kick_off_l") {
                this.log("‚è±Ô∏è", "Kick off! Returning to position");
                this.waitingAfterGoal = false;
                if (this.position === "l") {
                    this.moveTo(-15, 0);
                } else {
                    this.moveTo(15, 0);
                }
            }
        }
    }

    handleInit(data) {
        this.position = data.p[0];
        this.playerNumber = data.p[1];
        this.initialized = true;
        this.currentOrientation = this.position == "l" ? 0 : 180;
        this.log("‚úÖ", "Agent initialized successfully", {
            position: this.position,
            number: this.playerNumber,
            isGoalie: this.isGoalie
        });
    }

    handleSense(data) {
        this.lastSense = data;
        this.log("DEBUG", "Sense body received", {
            time: data.p[0],
            stamina: data.p[2] ? data.p[2][1] : 'unknown'
        });
    }

    smoothPosition(newPos) {
        if (!newPos) return this.currentPos;
        this.posHistory.push({...newPos});
        if (this.posHistory.length > this.posHistoryMax) this.posHistory.shift();
        if (this.posHistory.length < 3) return newPos;
        let sumX = 0, sumY = 0;
        for (let pos of this.posHistory) { sumX += pos.x; sumY += pos.y; }
        return { x: sumX / this.posHistory.length, y: sumY / this.posHistory.length };
    }

    handleSee(data) {
        const time = data.p[0];

        if (this.waitingAfterGoal) {
            this.log("DEBUG", `Waiting after goal (goal at ${this.goalScoredTime}), ignoring see and staying still.`);
            return;
        }

        if (!this.run) {
            this.log("DEBUG", "See message ignored - game not started");
            return;
        }

        this.visibleObjects = [];
        const visibleFlags = [];
        let ball = null;
        let targetGoal = null;
        let teammates = [];
        let opponents = [];

        this.log("DEBUG", `Processing see message at time ${time}, ${data.p.length - 1} objects`);

        for (let i = 1; i < data.p.length; i++) {
            const obj = data.p[i];
            if (!obj.cmd || !obj.cmd.p) continue;

            let nameParts = [];
            for (let j = 0; j < obj.cmd.p.length; j++) nameParts.push(obj.cmd.p[j]);
            const name = nameParts.join(" ");

            if (obj.p && obj.p.length >= 2) {
                const distance = obj.p[0];
                const direction = obj.p[1];
                const distChange = obj.p[2] || 0;
                const dirChange = obj.p[3] || 0;

                const object = { name, distance, direction, distChange, dirChange, time };
                this.visibleObjects.push(object);

                if (name == "b") {
                    ball = object;
                    this.log("‚öΩ", "Ball seen", { distance: distance.toFixed(2), direction: direction.toFixed(2) });
                }
                if (name == "g r" || name == "g l") {
                    targetGoal = object;
                }
                if (name.startsWith("f") && Flags[name]) visibleFlags.push(object);
                if (name.startsWith("p")) {
                    if (this.position === "l") {
                        if (name.includes("teamA") || (name === "p" && !name.includes("teamB"))) teammates.push(object);
                        else opponents.push(object);
                    } else {
                        if (name.includes("teamB") || (name === "p" && !name.includes("teamA"))) teammates.push(object);
                        else opponents.push(object);
                    }
                }
            }
        }

        if (visibleFlags.length >= 2) {
            this.log("DEBUG", `Triangulating with ${visibleFlags.length} flags`);
            const solutions = Localization.triangulate(visibleFlags[0], visibleFlags[1]);

            if (solutions) {
                let pos;
                if (visibleFlags.length >= 3) {
                    pos = Localization.resolveWithThirdFlag(solutions.sol1, solutions.sol2, visibleFlags[2]);
                } else {
                    pos = solutions.sol1;
                }

                if (Math.abs(pos.x) > 60 || Math.abs(pos.y) > 45) {
                    this.log("WARN", "Position out of bounds, ignoring", { x: pos.x.toFixed(2), y: pos.y.toFixed(2) });
                } else {
                    this.currentPos = this.smoothPosition(pos);
                    this.currentOrientation = Localization.computeOrientation(pos, visibleFlags[0]);
                    this.log("üìç", "Position calculated", {
                        x: this.currentPos.x.toFixed(2),
                        y: this.currentPos.y.toFixed(2),
                        orientation: this.currentOrientation.toFixed(2)
                    });

                    this.dribbleState.lastPositions.push({...this.currentPos, time: Date.now()});
                    if (this.dribbleState.lastPositions.length > 20) {
                        this.dribbleState.lastPositions.shift();
                    }
                }
            }
        }

        this.lastSee = { time, ball, targetGoal, flags: visibleFlags, teammates, opponents, all: this.visibleObjects };

        if (this.decisionTree) {
            try {
                const decision = this.decisionTree.decide({
                    time,
                    ball,
                    targetGoal,
                    flags: visibleFlags,
                    teammates,
                    opponents,
                    hear: this.lastHear,
                    pos: this.currentPos
                });

                if (decision) {
                    this.log("üéØ", `Decision: ${decision.cmd}`, { params: decision.params });

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç—å —É–¥–∞—Ä–∞
                    if (decision.cmd === "kick") {
                        if (ball && ball.distance <= 1.5) {
                            this.dribbleState.lastKickResult = true;
                            this.dribbleState.missedKicks = 0;
                            this.log("‚úÖ", "Good kick position", { distance: ball.distance.toFixed(2) });
                        } else {
                            this.dribbleState.lastKickResult = false;
                            this.dribbleState.missedKicks++;
                            this.log("‚ùå", "Bad kick position", {
                                distance: ball ? ball.distance.toFixed(2) : 'unknown',
                                missed: this.dribbleState.missedKicks
                            });

                            // –ï—Å–ª–∏ –º–Ω–æ–≥–æ –ø—Ä–æ–º–∞—Ö–æ–≤ –ø–æ–¥—Ä—è–¥ - –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
                            if (this.dribbleState.missedKicks > 3) {
                                this.log("‚ö†Ô∏è", "Too many misses - approaching closer");
                                this.dribbleState.missedKicks = 0;
                                // –í–º–µ—Å—Ç–æ —É–¥–∞—Ä–∞ –ø–æ–¥–æ–π–¥–µ–º –±–ª–∏–∂–µ
                                if (ball) {
                                    this.socketSend("dash", "40");
                                    return;
                                }
                            }
                        }
                    }

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞—Å—Ç—Ä–µ–≤–∞–Ω–∏–µ
                    if (decision.cmd === "kick") {
                        const kickKey = `${decision.params[0]}_${decision.params[1]}`;

                        if (this.dribbleState.lastKickCommand === kickKey) {
                            this.dribbleState.sameKickCount++;
                            if (this.dribbleState.sameKickCount > 5) {
                                this.log("üÜò", "STUCK DETECTED!");
                                this.dribbleState.sameKickCount = 0;
                                this.dribbleState.lastKickCommand = null;

                                if (ball) {
                                    // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º—Å—è –∫ –º—è—á—É –∏ –ø–æ–¥—Ö–æ–¥–∏–º –±–ª–∏–∂–µ
                                    if (Math.abs(ball.direction) > 5) {
                                        this.socketSend("turn", ball.direction.toFixed(2));
                                    } else {
                                        this.socketSend("dash", "40");
                                    }
                                    return;
                                }
                            }
                        } else {
                            this.dribbleState.sameKickCount = 0;
                            this.dribbleState.lastKickCommand = kickKey;
                        }
                    } else {
                        this.dribbleState.sameKickCount = 0;
                        this.dribbleState.lastKickCommand = null;
                    }

                    this.socketSend(decision.cmd, ...decision.params);
                    return;
                }
            } catch (e) {
                this.log("ERROR", "Decision tree error", { error: e.message });
            }
        }

        this.log("WARN", "Using fallback action");
        this.executeCurrentAction(time, targetGoal);
    }

    executeCurrentAction(time, targetGoal) {
        if (this.currentRouteIndex >= this.route.length) this.currentRouteIndex = 0;
        const action = this.route[this.currentRouteIndex];
        if (time % 20 === 0) {
            const actionIcon = action.act === 'flag' ? 'üö©' : '‚öΩ';
            this.log("‚ÑπÔ∏è", `Fallback action: [${this.currentRouteIndex}] ${actionIcon} ${action.name}`);
        }
        if (action.act === "flag") this.moveToFlag(action.name, time);
        else if (action.act === "dribble") this.dribbleToGoal(targetGoal, time);
    }

    moveToFlag(flagName, time) {
        const targetFlag = this.visibleObjects.find(obj => obj.name === flagName);
        if (!targetFlag) {
            this.noTargetCounter++;
            this.log("üëÄ", `Flag ${flagName} not visible, turning`);
            if (flagName.includes("r")) this.socketSend("turn", "45");
            else if (flagName.includes("l")) this.socketSend("turn", "-45");
            else this.socketSend("turn", "30");
            return;
        }

        this.noTargetCounter = 0;
        const distance = targetFlag.distance;
        const direction = targetFlag.direction;

        this.log("üö©", `Moving to flag ${flagName}`, { distance: distance.toFixed(2), direction: direction.toFixed(2) });

        if (distance < 3.0) {
            this.log("‚úÖ", `Flag ${flagName} reached ‚Üí index ${this.currentRouteIndex + 1}`);
            this.currentRouteIndex++;
            return;
        }

        if (Math.abs(direction) > 5) {
            this.socketSend("turn", direction.toFixed(2));
        } else {
            let dashPower = distance < 10 ? 70 : 100;
            this.socketSend("dash", dashPower.toString());
        }
    }

    needsOrbit(ballDir, goalDir) {
        return false;
    }

    isStuck() {
        if (this.dribbleState.lastPositions.length < 10) return false;

        const first = this.dribbleState.lastPositions[0];
        const last = this.dribbleState.lastPositions[this.dribbleState.lastPositions.length - 1];

        const distance = Math.sqrt(
            Math.pow(last.x - first.x, 2) +
            Math.pow(last.y - first.y, 2)
        );

        const timeDiff = (last.time - first.time) / 1000;

        if (timeDiff > 3 && distance < 1.0) {
            this.log("‚ö†Ô∏è", "Agent is stuck!", { distance: distance.toFixed(2), timeDiff: timeDiff.toFixed(1) });
            return true;
        }

        return false;
    }

    /**
     * –ê–ö–¢–ò–í–ù–ê–Ø –ó–ê–©–ò–¢–ê
     */
    defendGoal(ball, targetGoal, time) {
        this.log("üõ°Ô∏è", "Active defense", {
            ballDist: ball ? ball.distance.toFixed(2) : 'none',
            pos: this.currentPos ? this.currentPos.x.toFixed(2) : 'none'
        });

        if (ball && ball.distance < 15) {
            this.log("‚öΩ", "Ball near goal - clearing!");
            this.dribbleState.defensiveMode = "clear";

            let clearDirection;
            if (this.currentPos && this.currentPos.x < -30) {
                clearDirection = 0;
            } else {
                clearDirection = ball.direction;
            }

            if (ball.distance < 2.0) {
                return { cmd: "kick", params: ["50", clearDirection.toFixed(2)] };
            } else {
                if (Math.abs(ball.direction) > 10) {
                    return { cmd: "turn", params: [ball.direction.toFixed(2)] };
                } else {
                    return { cmd: "dash", params: ["80"] };
                }
            }
        }

        if (this.currentPos && this.currentPos.x < -30) {
            this.dribbleState.defensiveMode = "position";

            if (Math.random() < 0.3) {
                return { cmd: "turn", params: ["0"] };
            } else {
                return { cmd: "dash", params: ["50"] };
            }
        }

        if (ball) {
            if (Math.abs(ball.direction) > 20) {
                return { cmd: "turn", params: [ball.direction.toFixed(2)] };
            }
        }

        return { cmd: "turn", params: ["10"] };
    }

    dribbleToGoal(targetGoal, time) {
        const ball = this.visibleObjects.find(obj => obj.name === "b");

        if (!ball) {
            this.log("üîç", "Ball lost - searching");
            this.socketSend("turn", "45");
            return;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ –º—è—á–∞
        if (Math.abs(ball.distance - this.dribbleState.lastBallDistance) < 0.1) {
            this.dribbleState.stuckCounter++;

            if (this.dribbleState.stuckCounter > 10) {
                this.log("üÜò", "COMPLETELY STUCK! Forcing escape action");
                this.dribbleState.stuckCounter = 0;

                const escapeDir = ball.direction > 0 ? -45 : 45;
                this.socketSend("turn", escapeDir.toString());
                setTimeout(() => {
                    this.socketSend("dash", "80");
                }, 100);
                return;
            }
        } else {
            this.dribbleState.stuckCounter = 0;
        }
        this.dribbleState.lastBallDistance = ball.distance;

        // –ï—Å–ª–∏ –º—ã –≤ –∑–∞—â–∏—Ç–µ
        if (this.currentPos && this.currentPos.x < -20) {
            const defendAction = this.defendGoal(ball, targetGoal, time);
            if (defendAction) {
                this.socketSend(defendAction.cmd, ...defendAction.params);
                return;
            }
        }

        this.log("‚öΩ", "Offensive state", {
            ballDist: ball.distance.toFixed(2),
            ballDir: ball.direction.toFixed(2),
            goalDir: targetGoal ? targetGoal.direction.toFixed(2) : 'none',
            kicks: this.dribbleState.consecutiveKicks,
            missed: this.dribbleState.missedKicks
        });

        // === –ï–°–õ–ò –ú–Ø–ß –î–ê–õ–ï–ö–û - –ü–†–ò–ë–õ–ò–ñ–ê–ï–ú–°–Ø ===
        if (ball.distance > 1.2) {
            if (Math.abs(ball.direction) > 10) {
                this.socketSend("turn", ball.direction.toFixed(2));
            } else {
                let dashPower = ball.distance > 8 ? 90 : 70;
                this.socketSend("dash", dashPower.toString());
            }
            return;
        }

        // === –ú–Ø–ß –†–Ø–î–û–ú ===
        if (ball.distance <= 1.2) {
            // –ï—Å–ª–∏ –º–Ω–æ–≥–æ –ø—Ä–æ–º–∞—Ö–æ–≤ - –ø–æ–¥—Ö–æ–¥–∏–º –µ—â–µ –±–ª–∏–∂–µ
            if (this.dribbleState.missedKicks > 2) {
                this.log("üéØ", "Approaching closer for better kick");
                this.socketSend("dash", "30");
                return;
            }

            // –ï—Å–ª–∏ –≤–æ—Ä–æ—Ç –Ω–µ –≤–∏–¥–Ω–æ
            if (!targetGoal) {
                this.log("üëÄ", "Goal not visible - searching with small turns");
                this.dribbleState.searchMode = true;
                this.socketSend("turn", "20");
                return;
            }

            this.dribbleState.searchMode = false;

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞—Å—Ç—Ä–µ–≤–∞–Ω–∏–µ
            const stuck = this.isStuck();
            if (stuck || this.dribbleState.stuckCounter > 5) {
                this.log("‚ö†Ô∏è", "Stuck detected - forcing escape!");
                this.dribbleState.stuckCounter = 0;
                this.dribbleState.consecutiveKicks = 0;

                const escapeDir = Math.random() > 0.5 ? 45 : -45;
                this.socketSend("turn", escapeDir.toString());
                setTimeout(() => {
                    this.socketSend("dash", "80");
                }, 100);
                return;
            }

            // –í —à—Ç—Ä–∞—Ñ–Ω–æ–π - —Å–∏–ª—å–Ω—ã–π —É–¥–∞—Ä
            const inPenaltyArea = (this.currentPos.x > 36 && Math.abs(this.currentPos.y) < 20.15);

            if (inPenaltyArea || targetGoal.distance < 25) {
                this.log("üí•", "SHOOTING!");
                this.socketSend("kick", "100", targetGoal.direction.toFixed(2));
                this.dribbleState.consecutiveKicks = 0;
                return;
            }

            // –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —É–¥–∞—Ä–æ–≤ –±–µ–∑ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
            if (this.dribbleState.consecutiveKicks > 8) {
                this.log("‚ö†Ô∏è", "Too many kicks without progress");
                this.dribbleState.consecutiveKicks = 0;
                this.socketSend("kick", "30", targetGoal.direction.toFixed(2));
                return;
            }

            // –î—Ä–∏–±–ª–∏–Ω–≥ –∫ –≤–æ—Ä–æ—Ç–∞–º
            this.log("‚öΩ", "Pushing ball toward goal");

            let kickPower = 15;
            if (targetGoal.distance > 40) {
                kickPower = 25;
            } else if (targetGoal.distance < 30) {
                kickPower = 12;
            }

            // –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            if (Math.abs(targetGoal.direction) > 20) {
                const correction = targetGoal.direction * 0.4;
                this.socketSend("kick", kickPower.toString(), correction.toFixed(1));
            } else {
                this.socketSend("kick", kickPower.toString(), "0");
            }

            this.dribbleState.consecutiveKicks++;
        }
    }

    moveTo(x, y) {
        if (!this.initialized) {
            this.log("‚è≥", "Waiting for initialization before move");
            setTimeout(() => this.moveTo(x, y), 500);
            return;
        }
        this.log("üì¶", `Moving to position: (${x}, ${y})`);
        this.socketSend("move", x.toString(), y.toString());
    }
}

module.exports = Agent;