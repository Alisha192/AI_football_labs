// agent.js - Полностью исправленная версия для работы 1
const Msg = require('./msg');
const readline = require('readline');
const Localization = require('./localization');
const Flags = require('./flags');

class Agent {
    constructor() {
        this.position = "l";           // По умолчанию - левая половина поля
        this.run = false;               // Игра начата
        this.act = null;                // Действия
        this.socket = null;
        this.playerNumber = null;
        this.initialized = false;

        // Для задания 2: вращение
        this.rotateSpeed = 10;
        this.rotateDirection = 1;

        // Для задания 4-5: противник
        this.opponentPos = null;

        // Отладка
        this.messageCount = 0;
        this.lastSeeTime = 0;

        // Чтение консоли (как в методичке)
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        this.rl.on('line', (input) => {
            if (this.run) {
                if ("w" == input) this.act = { n: "dash", v: 100 };
                if ("d" == input) this.act = { n: "turn", v: 20 };
                if ("a" == input) this.act = { n: "turn", v: -20 };
                if ("s" == input) this.act = { n: "kick", v: 100 };
            }
        });
    }

    setSocket(socket) {
        this.socket = socket;
    }

    socketSend(cmd, value) {
        // Отправка в формате (cmd value)
        this.socket.sendMsg(`(${cmd} ${value})`);
    }

    handleMessage(msg) {
        this.messageCount++;

        // Отладка: показываем первые 50 символов каждого сообщения
        // console.log(`RAW[${this.messageCount}]: ${msg.substring(0, 50)}...`);

        let data = Msg.parseMsg(msg);
        if (!data) {
            console.log("Parse error\n" + msg);
            return;
        }

        // Обработка разных типов сообщений
        if (data.cmd == "hear") {
            this.handleHear(data);
        }
        else if (data.cmd == "init") {
            this.handleInit(data);
        }
        else if (data.cmd == "see") {
            this.handleSee(data);
        }
        else if (data.cmd == "sense_body") {
            this.handleSenseBody(data);
        }
    }

    handleHear(data) {
        // Проверяем начало игры
        if (data.p[1] == "referee" && data.p[2] == "play_on") {
            console.log("Game started!");
            this.run = true;
        }

        // Проверяем другие сообщения (для отладки)
        if (data.p[1] == "referee") {
            // console.log(`Referee: ${data.p[2]}`);
        }
    }

    handleInit(data) {
        // (init l 3 before_kick_off)
        this.position = data.p[0];      // "l" или "r"
        this.playerNumber = data.p[1];
        this.initialized = true;
        console.log(`Agent initialized: ${this.position}${this.playerNumber}`);
    }

    handleSee(data) {
        if (!this.run) return;

        const time = data.p[0];
        if (time > this.lastSeeTime) {
            this.lastSeeTime = time;
        }

        // Массивы для разных типов объектов
        const visibleFlags = [];
        const visiblePlayers = [];
        let ball = null;
        let opponent = null;

        // Парсим все видимые объекты
        for (let i = 1; i < data.p.length; i++) {
            const obj = data.p[i];
            if (!obj.cmd || !obj.cmd.p) continue;

            // Формируем имя объекта из частей
            let nameParts = [];
            for (let j = 0; j < obj.cmd.p.length; j++) {
                nameParts.push(obj.cmd.p[j]);
            }
            const name = nameParts.join(" ");

            // У obj.p - параметры: [distance, direction, distChange, dirChange]
            if (obj.p && obj.p.length >= 2) {
                const distance = obj.p[0];
                const direction = obj.p[1];

                const object = {
                    name: name,
                    distance: distance,
                    direction: direction
                };

                // Определяем тип объекта по имени
                if (name.startsWith("f")) {
                    // Это флаг - проверяем, знаем ли мы его координаты
                    if (Flags[name]) {
                        visibleFlags.push(object);
                    } else {
                        // Неизвестный флаг - игнорируем
                        // console.log(`Unknown flag: "${name}"`);
                    }
                }
                else if (name == "b") {
                    // Это мяч
                    ball = object;
                }
                else if (name.startsWith("p")) {
                    // Это игрок
                    visiblePlayers.push(object);

                    // Определяем, свой или чужой (упрощенно)
                    if (!name.includes("teamA")) {
                        opponent = object;
                    }
                }
            }
        }

        // Задание 3: вычисляем свои координаты по флагам
        if (visibleFlags.length >= 2) {
            // Берем первые два флага для триангуляции
            const flag1 = visibleFlags[0];
            const flag2 = visibleFlags[1];

            // Отладка: показываем используемые флаги
            // console.log(`Using flags: "${flag1.name}" (${flag1.distance}, ${flag1.direction}) and "${flag2.name}" (${flag2.distance}, ${flag2.direction})`);

            const solutions = Localization.triangulate(flag1, flag2);

            if (solutions) {
                let pos;

                // Если есть третий флаг - используем для выбора решения
                if (visibleFlags.length >= 3) {
                    pos = Localization.resolveWithThirdFlag(
                        solutions.sol1,
                        solutions.sol2,
                        visibleFlags[2]
                    );
                } else {
                    // Иначе берем первое решение (обычно правильное для левой половины)
                    pos = solutions.sol1;
                }

                // Вычисляем ориентацию по первому флагу
                const orientation = Localization.computeOrientation(pos, flag1);

                // Выводим координаты (задание 3)
                console.log(`Time ${time}: Position = (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}), Orientation = ${orientation.toFixed(2)}`);

                // Задание 5: вычисляем координаты противника
                if (opponent) {
                    const oppPos = Localization.locateOtherPlayer(pos, orientation, opponent);
                    console.log(`  Opponent at (${oppPos.x.toFixed(2)}, ${oppPos.y.toFixed(2)})`);
                    this.opponentPos = oppPos;
                }
            }
        } else {
            // Мало флагов для定位 - просто вращаемся в поисках
            // console.log(`Only ${visibleFlags.length} flags visible, turning to find more...`);
        }

        // Задание 2: вращаем игрока (если скорость > 0)
        if (this.run && this.rotateSpeed > 0) {
            this.socketSend("turn", this.rotateSpeed * this.rotateDirection);
        }
    }

    handleSenseBody(data) {
        // Можно использовать для отслеживания выносливости
        // Парсим stamina если нужно
        if (data.p && data.p.length > 2) {
            // Ищем stamina в сообщении
            for (let i = 0; i < data.p.length; i++) {
                if (data.p[i] && data.p[i].cmd == "stamina") {
                    // console.log(`Stamina: ${data.p[i].p[0]}`);
                }
            }
        }
    }

    // Задание 1: перемещение в начальные координаты
    moveTo(x, y) {
        if (!this.initialized) {
            // Если еще не инициализирован, ждем и пробуем снова
            setTimeout(() => this.moveTo(x, y), 500);
            return;
        }
        // Отправляем команду move без лишних скобок внутри
        this.socketSend("move", `${x} ${y}`);
        console.log(`Moving to (${x}, ${y})`);
    }

    // Для отправки команд из консоли (из методички)
    sendCmd() {
        if (this.run && this.act) {
            if (this.act.n == "kick") {
                this.socketSend(this.act.n, this.act.v + " 0");
            } else {
                this.socketSend(this.act.n, this.act.v);
            }
            this.act = null;
        }
    }
}

module.exports = Agent;